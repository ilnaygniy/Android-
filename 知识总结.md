# Android知识总结

​	daydayup

![android](https://raw.githubusercontent.com/ilnaygniy/picBed/master/android.png)

## 一、 Handler消息机制

### 1 什么是handler？

​	handler是**进程内部**、线程间的一种通信机制

###  **2 Handler、Looper、MessageQueen、Message的关系**

​	*Message：消息对象*

​	*MessageQueen: 存储消息对象的队列*

​	*Looper:负责循环读取MessageQueen中的消息，读到消息之后就把消息交给Handler去处理。*

​	*Handler：发送消息和处理消息*

​	*一个线程只可以创建一个Looper，使用Looper.prepare()方法创建，同时创建MessageQueen，间接保证一个线程只有一个MessageQueue对象。Handler可以有多个。*

​	**Looper**：用来为一个线程开启一个消息循环，子线程使用handler需要先调用Looper.prepare()创建一个Looper对象，再prepare方法中先通过sThreadLocal.get()（[ThreadLocal]()，线程本地存储区）方法获取Looper，

​		`Looper.prepare()`

​		`代码·······`

​		`Loop.loop();`

Looper.loop(); 让Looper开始工作，从消息队列里循环取消息，处理消息。注意：写在Looper.loop()之后的代码不会被执行，这个函数内部应该是一个循环，当调用mHandler.getLooper().quit()后，loop才会中止，其后的代码才能得以运行。

​	**为什么主线程不会因为Looper.loop()方法造成阻塞（ANR）**：在处理消息的时候使用了Looper.loop()方法，并且在该方法中进入了一个死循环;

​	源码ActivityThread（并不是一个 Thread） 类中

```
public final class ActivityThread{
public static void main(String[] args) {
   
   ········

    Looper.prepareMainLooper();

 	 ·······
    ActivityThread thread = new ActivityThread();
    thread.attach(false, startSeq);

   ····
    Looper.loop();

    throw new RuntimeException("Main thread loop unexpectedly exited");
}}
```

​	主线程是随着APP的启动而启动,随着APP的结束而结束的，app启动之初，就已经创建Looper，app要一直运行直到用户主动退出，所以需要Looper一直循环，app退出，方能执行剩余代码。真正导致主线程卡住的是处理某一个*消息耗时太长，导致阻塞了其他消息，其他消息得不到处理*，出现 ANR。 

​	**Activity的生命周期都是依靠主线程的Looper.loop，当收到不同Message时则采用相应措施**

​	**从系统进程system_server看：**

1. 当系统收到来自因用户操作而产生的通知时, 会通过 Binder 方式从系统进程跨进程的通知我们的 application 进程中的 `ApplicationThread`,
2. `ApplicationThread`又通过 Handler 机制往主线程的 `messageQueue`中插入消息
3. 从而让主线程的`loop()`，`Message msg = queue.next()`这句代码可捕获一条 message ,然后通过 `msg.target.dispatchMessage(msg)`来处理消息,从而实现了整个 Android 程序能够响应用户交互和回调生命周期方法（具体实现ActivityThread 中的内部类H中有实现）



### 3 HandlerThread



    public class MainActivity extends AppCompatActivity {
    private String TAG = "testHandler";
    private Handler myHandler;
    
    class MyThread extends Thread {
        public Looper myThreadLooper;
        @Override
        public void run() {
            super.run();
            Looper.prepare();
            myThreadLooper = Looper.myLooper();
            Looper.loop();
        }
    }
    
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
    
        //创建子线程并启动
        final MyThread myThread = new MyThread();
        myThread.start();
        //将子线程的Looper对象赋给myHandler
        myHandler = new Handler(myThread.myThreadLooper) {
            @Override
            public void handleMessage(Message msg) {
                super.handleMessage(msg);
                Log.e(TAG, "msg what:" + msg.what);
            }
        };
        myHandler.sendEmptyMessage(2);
    }
    }


​	在上述代码中涉及到两个线程：UI线程和一个子线程；在UI线程中试图将子线程的Looper对象赋给Handler对象，在子线程运行的时候获取自己的Looper对象。

​	运行的时候会报NullPointerException，即Looper对象为空。

​	产生上述错误的原因在于多线程并发，当UI线程执行到赋值操作的时候，子线程中的Looper对象还没有创建成功。

**使用HandlerThread可以很方便的避免上述多线程并发带来的问题。**



    public class MainActivity extends AppCompatActivity {
    private String TAG = "testHandler";
    private Handler myHandler;
    
    private HandlerThread myThread;
    
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
    
        //创建子线程并启动
        myThread = new HandlerThread("MyThreadHandler");
        myThread.start();
    
        //将子线程的Looper对象赋给myHandler
        myHandler = new Handler(myThread.getLooper()) {
            @Override
            public void handleMessage(Message msg) {
                super.handleMessage(msg);
                Log.e(TAG, "msg what:" + msg.what);
            }
        };
        myHandler.sendEmptyMessage(2);
    }
    }
HandlerThread的getLooper()方法中已经做了相关处理


​        

    public Looper getLooper() {
        if (!isAlive()) {
            return null;
        }
       // If the thread has been started, wait until the looper has been created.
        synchronized (this) {
            while (isAlive() && mLooper == null) {
                try {
                    wait();
                } catch (InterruptedException e) {
                }
            }
        }
        return mLooper;
    }
在HandlerThread中如果Looper对象没有创建成功，则当前线程一直处于等待状态。

HandlerThread的唤醒源代码如下：

    @Override
    public void run() {
        mTid = Process.myTid();
        Looper.prepare();
        synchronized (this) {
            mLooper = Looper.myLooper();
            notifyAll();
        }
        Process.setThreadPriority(mPriority);
        onLooperPrepared();
        Looper.loop();
        mTid = -1;
    }
在HandlerThread的run方法中如果Looper对象创建成功，则唤醒所有等待线程。



### 4 ThreadLocal

​	ThreadLocal<T> 是与线程绑定的一个变量。ThreadLocal和Synchonized都用于解决多线程并发访问。但是ThreadLocal与synchronized有本质的区别。Synchronized用于线程间的数据共享，而ThreadLocal则用于线程间的数据隔离。Synchronized是利用锁的机制，使变量或代码块在某一时该只能被一个线程访问。而ThreadLocal为每一个线程都提供了变量的副本，使得每个线程在某一时间访问到的并不是同一个对象，这样就隔离了多个线程对数据的数据共享。而Synchronized却正好相反，它用于在多个线程间通信时能够获得数据共享。

​	一句话理解ThreadLocal，向ThreadLocal里面存东西就是向它里面的Map存东西的，然后ThreadLocal把这个Map挂到当前的线程底下，这样Map就只属于这个线程了。

​	

#### 后续补充=等



## 二 Binder 机制

### 1	APP从启动到主页面显示经历了哪些过程？



![app1](https://raw.githubusercontent.com/ilnaygniy/picBed/master/app1.png)

启动流程：

①点击桌面App图标，Launcher进程采用Binder IPC向system_server进程发起startActivity请求；

②system_server进程接收到请求后，向zygote进程发送创建进程的请求；

③Zygote进程fork出新的子进程，即App进程；

④App进程，通过Binder IPC向sytem_server进程发起attachApplication请求；

⑤system_server进程在收到请求后，进行一系列准备工作后，再通过binder IPC向App进程发送scheduleLaunchActivity请求；

⑥App进程的binder线程（ApplicationThread）在收到请求后，通过handler向主线程发送LAUNCH_ACTIVITY消息；

⑦主线程在收到Message后，通过发射机制创建目标Activity，并回调Activity.onCreate()等方法。

⑧到此，App便正式启动，开始进入Activity生命周期，执行完onCreate/onStart/onResume方法，UI渲染结束后便可以看到App的主界面。

原：https://www.jianshu.com/p/a72c5ccbd150



### 2 Binder 的理解

#### 2.1 为什么用Binder

进程间通信，Android基于Linux：

- 操作系统的不同进程之间，数据不共享；对于每个进程来说都以为自己独享了整个系统，因此进程间通信需要某种**系统机制**才能完成；

- 用户程序只可以访问某些许可资源，不许可资源被拒绝访问。于是可认为分为**内核空间**和**用户空间**；

- 用户空间访问内核空间的卫衣方式就是**系统调用**，通过统一入口，所有资源访问都在内核控制下进行，以免越权，保证安全稳定；

- 一个用户想与另一个用户空间进行通信，一般需要操作系统内核支持。

- Linux有个比较好的机制，就是可以**动态加载内核模块**；模块具有独立功能的程序，它可以被单独编译，但不能单独运行。它运行时被链接到内核的作为内核的一部分并在内核空间运行。


  这样，Android系统就可以在Linux的基础之上，通过添加一个内核模块运行在内核空间，用户进程之间可通过这个模块完成通信。这个模块就是所谓的 **Binder驱动** .

- Linux已拥有的进程间通信IPC手段包括： Pipe、Signal、Socket、Message、Share Memory 和信号量Semaphore.

为什么单独弄一套进程间通信方式（不同Linux系统提供的进程间通信方式）：性能、安全、易用；

- 使用Linux 提供的系统调用接口：copy_from_user()和copy_to_user() 来实现进程间通信，缺点是效率低下，需要做两次拷贝：用户空间->内核空间->用户空间。
  Binder驱动 为了实现用户空间到用户空间的拷贝：mmap()分配的内存除了映射进了接收方进程里，还映射进了内核空间。所以调用copy_from_user()将数据拷贝进内核空间也相当于拷贝进了接收方的用户空间， 所以Binder机制只需要一次拷贝。
- 而共享内存的话，效率比较高， 但控制复杂….
- 安全性:  传统IPC没有任何安全措施，完全依赖上层协议来确保；传统IPC访问接入点是开放的，无法建立私有通道；例如Socket通信的话，socket的ip地址或文件名都是开放的，只要知道这些接入点的程序都可以和对端建立连接，不管怎样都无法阻止恶意程序通过猜测接收方地址获得连接。

```
Binder基于Client-Server通信模式，传输过程只需一次拷贝，为发送发添加UID/PID身份，既支持实名Binder也支持匿名Binder，安全性高。
```



#### 2.2 从Activity的启动流程理解Binder

AMS（ActivityManagerService ）和APP跨进程的过程简单说就是C端和S端分别通过二者在对方的代理去互相调用对方方法的过程。

为什么不在客户端直接new一个Activity: 因为Android的安全机制以及为了统一管理Activity（比如activity栈），需要一个统一的管理（AMS）。AMS运行在一个**单独的进程**，因此App端如果想发起一个Activity请求，需要先把申请提交给AMS，AMS处理完这给请求之后，需要再次跨进程通知App端去执行剩下的工作。因此核心在于两者如何互相调用对象。



**1）App端如何调用AMS**

​	用户启动一个页面时，会依次调用activity的startActivity-->Instrumentation的executestartActivity-->execStartActivitiesAsUser，在最后这个方法里，执行了远程调用，即：

```java
 int result = ActivityManager.getService()
                .startActivities(whoThread, who.getBasePackageName(), intents, resolvedTypes,
                        token, options, userId);
```

ActivityManager.getService :取得的是AMS在客户端的代理，也就是代码中的最后一行返回的am;

```java
  public static IActivityManager getService() {
        return IActivityManagerSingleton.get();
    }

    private static final Singleton<IActivityManager> IActivityManagerSingleton =
            new Singleton<IActivityManager>() {
                @Override
                protected IActivityManager create() {
                    final IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE);
                    final IActivityManager am = IActivityManager.Stub.asInterface(b);
                    return am;
                }
            };
```

因为App要频繁的调用AMS的方法，因此用单例模式缓存在本地了一个AMS的本地代理,从单例的第一次获取可以看到，AMS的Binder是通过ServiceManager.getService()获取到的，ServiceMangaer就是Android系统统一管理所有远程服务的工具，比如AMS，WMS等系统服务都在这里注册。

客户端想调用任意一个服务，只需要知道名字就可以通过SM获取到相应的Server的Binder。拿到Binder之后便可以通过asInterface静态方法转化成本地代理，从而调用server的方法了。因此第一次获取AMS的Binder的过程实际上是客户端跟ServiceManager的一次跨进程通信。

**2）AMS如何通知App进程**

​	从上面得知，App获取AMS的Binder实际上通过ServiceManager间接获取，那么AMS处理玩activity的管理任务（栈操作等）如何通知App？一个App不会像AMS那样在ServiceManger中注册（**AMS如何获取到App进程的Binder的**）：

​	**App跨进程调用AMS的方法时，还顺便把App进程（这个时候App可以看作是服务端了）的Binder作为参数传给了AMS，AMS拿到这个APP的Binder之后，通过asInterface方法转化成在server端可以使用的代理，然后在需要回调App进程的时候通过这个代理来通知客户端**。其实跟App端逻辑是一致的，只不过C/S调了一下顺序，C变成了S，S变成了C。

​	**获取到Binder之后**：AMS其实在App跨进程调用AMS的时候就把ApplicationThread转成Binder传过来了，传过来以后，AMS如果要用，必须得拿到ApplicationThread的代理，怎么拿到？：AMS的onTransact方法会监听驱动传过来的对象，我们看onTransact的代码：AMS继承自IActivityManager.Stub，在源码中叫ActivityManagerNative：

```java
public boolean onTransact(int code, Parcel data, Parcel reply, int flags)
            throws RemoteException {
        switch (code) {
        case START_ACTIVITY_TRANSACTION:
        {
            data.enforceInterface(IActivityManager.descriptor);
            IBinder b = data.readStrongBinder();
            IApplicationThread app = ApplicationThreadNative.asInterface(b);
```

可以看到：
IBinder b = data.readStrongBinder();客户端将binder  write到Parcel中，服务端从Parcel中读了出来，然后通过asInterface转换成ApplicationThread的代理ApplicationThreadProxy这个类。注意：Binder驱动过来的IBinder不是Binder，而是BinderProxy;

有了代理对象后接下来既可以直接用了：

```
int result = startActivity(app, intent, resolvedType,
                    grantedUriPermissions, grantedMode, resultTo, resultWho,
                    requestCode, onlyIfNeeded, debug, profileFile, profileFd, autoStopProfiler);
```

即进入到AMS对Activity启动管理流程中了，经过复杂的跳转，最后跑到ActivityStackSupervisor这个类的realStartActivityLocked方法中，里面最终会执行到这行代码：

```java
app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken,
                    System.identityHashCode(r), r.info, new Configuration(mService.mConfiguration),
                    r.compat, r.task.voiceInteractor, app.repProcState, r.icicle, r.persistentState,
                    results, newIntents, !andResume, mService.isNextTransitionForward(),
                    profilerInfo);
```

这里的app.thread就是前面ApplicationThread在AMS中的代理;

接下来通过代理调起App进程的ApplicationThread里的相应方法,即：scheduleLaunchActivity方法，这个方法会发送一个Message给主线程的handler ：H，然后在handleMessage里通过类加载器创建出一个Activity对象.......

![2573909-298fad8065f14ade](https://raw.githubusercontent.com/ilnaygniy/picBed/master/20201210173439.png)



## 三、Bundle 机制

### **什么是Bundle**

​	Bundle在app中是以AIDL的方式表现的

​	官方文档： A mapping from String values to various Parcelable types.

​	可以看出，它和Map类型有异曲同工之妙,同时实现了Parcelable接口，那么显然，它是支持进程间通讯的。所以，Bundle可以看做是一个特殊的Map类型，它支持进程间通讯，保存了特定的数据。Bundle主要用于传递数据；它保存的数据，是以key-value(键值对)的形式存在的；1

​	以下是Bundle的几个常用方法：①putXxx(String key,Xxx value):Xxx表示一系列的数据类型，比如String,int,float,Parcelable，Serializable等类型，以键-值对形式保存数据。②getXxx(String key):根据key值获取Bundle中的数据。

​	出现场合：Activity状态数据的保存与恢复涉及到的两个回调：`void onSaveInstanceState (Bundle outState)`、`void onCreate (Bundle savedInstanceState)`； Fragment的setArguments方法：`void setArguments (Bundle args)`； 消息机制中的Message的setData方法：`void setData (Bundle data)`等



### **Bundle的使用**

​	1、在activity间传递信息（Bundle只是一个信息的载体，内部其实就是维护了一个Map<String,Object>。

Intent负责Activity之间的交互，内部是持有一个Bundle的。）

​	2、读取数据

​	3、线程间传递

​	通过Handler将带有dundle数据的message放入消息队列，其他线程就可以从队列中得到数据

```
 Message message=new Message();

 Bundle bundle = new Bundle();

 message.setData(bundle);

 mHandler.sendMessage(message)；
```



#### 后续补充



## 四、线程、线程池

### 1 线程

**Thread**

**AysncTask**：底层封装了线程池和Handler,方便开发者在子线程中更新ui。（不推荐使用）

**Handler**：具有消息循环的线程，内部可以使用Handler。

**IntentService**：是一个服务，可执行后台任务，内部采用了HandlerThread来执行任务，任务执行完毕IntentService会自动退出。

**传统线程的缺陷**
	 1在任务众多的情况下，系统要为每一个任务创建一个线程，而任务执行完毕后会销毁每一个线程，所以会造成线程频繁地创建与销毁。
	 2多个线程频繁地创建会占用大量的资源，并且在资源竞争的时候就容易出现问题，同时这么多的线程缺乏一个统一的管理，容易造成界面的卡顿。
	 3多个线程频繁地销毁，会频繁地调用GC机制，这会使性能降低，又非常耗时。

#### 1.1wait和sleep的区别

sleep
1、让当前线程休眠指定时间，进入sleeping状态。
休眠时间的准确性依赖于系统时钟和CPU调度机制。
2、不释放已获取的锁资源，如果sleep方法在同步上下文中调用，那么其他线程是无法进入到当前同步块或者同步方法中的。
3、可通过调用interrupt()方法来唤醒休眠线程。
4、sleep方法定义在java.lang.Thread中，作用于当前线程
5、sleep是静态方法

wait
1、让当前线程进入等待状态，当别的其他线程调用notify()或者notifyAll()方法时，当前线程进入就绪状态
2、wait方法必须在同步上下文中调用，例如：同步方法块或者同步方法中，这也就意味着如果你想要调用wait方法，前提是必须获取对象上的锁资源
3、当wait方法调用时，当前线程将会释放已获取的对象锁资源，并进入等待队列，其他线程就可以尝试获取对象上的锁资源。
4、wait方法定义在Object类中，作用于对象本身；
5、wait是实例方法；

##### 1.2 notify

​	notify无法保证通知哪个线程，Wait()和notify()方法只能从synchronized方法或块中调用，需要在其他线程正在等待的对象上调用notify方法

##### 1.3 notify和notifyAll

1、notify只会随机选取一个处于等待池中的线程进入锁池去竞争获取锁的机会；
2、notifyAll会让所有处于等待池的线程全部进入锁池去竞争获取锁的机会；

### 2 线程池

**优点**
	1重用线程池中的线程，线程在执行完任务后不会立刻销毁，而会等待另外的任务，这样就不会频繁地创建、销毁线程和调用GC。。
	2有效控制线程池的最大并发数，避免大量线程抢占资源出现的问题。
	3对多个线程进行统一地管理，可提供定时执行及指定间隔循环执行的功能。

**使用**

四种线程池最终调用ThreadPoolExecutor 构造方法：

```java
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue,
                          ThreadFactory threadFactory)
```

**corePoolSize**： 线程池中核心线程的数量。固定线程数 可闲置 不会被销毁 ThreadPoolExecutor的allowCoreThreadTimeOut属性设置为true时，keepAliveTime同样会作用于核心线程
**maximumPoolSize**：线程池中最大线程数量。
**keepAliveTime**：非核心线程的超时时长，当系统中非核心线程闲置时间超过keepAliveTime之后，则会被回收。如果ThreadPoolExecutor的allowCoreThreadTimeOut属性设置为true，则该参数也表示核心线程的超时时长。
**unit**：keepAliveTime这个参数的单位，有纳秒、微秒、毫秒、秒、分、时、天等。
**workQueue**：线程池中的任务队列，该队列主要用来存储已经被提交但是尚未执行的任务。存储在这里的任务是由ThreadPoolExecutor的execute方法提交来的。
**threadFactory**：为线程池提供创建新线程的功能，这个我们一般使用默认即可。
 **handler: 拒绝策略，当线程无法执行新任务时（一般是由于线程池中的线程数量已经达到最大数或者线程池关闭导致的），默认情况下，当线程池无法处理新线程时，会抛出一个RejectedExecutionException。



**ThreadPoolExecutor 执行任务时大致遵循如下流程：**

- 1.如果线程池中的线程数未达到核心线程数，则会立马启用一个核心线程去执行。
- 2.如果线程池中的线程数已经达到核心线程数，且任务队列workQueue未满，则将新线程放入workQueue中等待执行。
- 3.如果线程池中的线程数已经达到核心线程数但未超过线程池规定最大值，且workQueue已满，则开启一个非核心线程来执行任务。
- 4.如果线程池中的线程数已经超过线程池规定最大值，则拒绝执行该任务，采取饱和策略，并抛出RejectedExecutionException异常。



#### 2.1四种线程池

##### FixedThreadPool (可重用固定线程数)

```java
//源码实现
public static ExecutorService newFixedThreadPool(int nThreads) {
        return new ThreadPoolExecutor(nThreads, nThreads,
                                      0L, TimeUnit.MILLISECONDS,
                                      new LinkedBlockingQueue<Runnable>());
    }
//创建及执行
ExecutorService fixedThreadPool = Executors.newFixedThreadPool(5);
//执行上述Demo的runnable
fixedThreadPool.execute(runnable);
```

结果：每3s打印5次任务，跟上面的基础线程池类似。
特点：参数为核心线程数，只有核心线程，无非核心线程无超时时长，并且阻塞队列无界。
**适用：执行长期的任务，性能好很多**



##### SingleThreadPool(单个核线的fixed)

```java
//源码实现
public static ExecutorService newSingleThreadExecutor() {
        return new FinalizableDelegatedExecutorService
            (new ThreadPoolExecutor(1, 1,                    
                                    0L, TimeUnit.MILLISECONDS,
                                    new LinkedBlockingQueue<Runnable>()));
    }//创建及执行
ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();
//执行上述Demo的runnable
singleThreadExecutor .execute(runnable);
```

结果：每3s打印1次任务。
特点：只有一个核心线程，当被占用时，其他的任务需要进入队列等待,fixedThreadPool设置核心线程为1时就是SingleThreadPool。
**适用：一个任务一个任务执行的场景**



##### CachedThreadPool (按需创建)

```java
//源码实现
public static ExecutorService newCachedThreadPool() {
        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                      60L, TimeUnit.SECONDS,
                                      new SynchronousQueue<Runnable>());
    }
//创建及执行
ExecutorService cachedThreadPool = Executors.newCachedThreadPool();
//执行上述Demo的runnable
cachedThreadPool.execute(runnable);
```

结果：3s后打印30次任务。
特点：没有核心线程，只有非核心线程，并且每个非核心线程空闲等待的时间为60s，采用SynchronousQueue队列。

**适用：执行很多短期异步的小程序或者负载较轻的服务器**

ScheduledThreadPool(定时延时执行)

```java
 //源码实现
 public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {
        return new ScheduledThreadPoolExecutor(corePoolSize);
    }
public ScheduledThreadPoolExecutor(int corePoolSize) {
        super(corePoolSize, Integer.MAX_VALUE,
              DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,
              new DelayedWorkQueue());
    }
```

特点：核心线程数量是固定的，非核心线程无穷大。当非核心线程闲置时，则会被立即回收。
ScheduledThreadPool也是四个当中唯一一个具有定时定期执行任务功能的线程池。它适合执行一些周期性任务或者延时任务。
**适用：一个任务一个任务执行的场景**。



#### 2.2 线程池疑问

##### 1 如何保证核心线程不被销毁

​	线程阻塞

	            Runnable r = timed ?
	                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
	                workQueue.take();
	                    if (r != null)
	                return r;
​	如果设置了allowCoreThreadTimeOut(true) 或者当前运行的任务数大于设置的核心线程数，那么timed =true 。此时将使用workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS)从任务队列中取任务，而如果没有设置，那么使用workQueue.take();取任务，对于阻塞队列，poll(long timeout, TimeUnit unit) 将会在规定的时间内去任务，如果没取到就返回null。take()会一直阻塞，等待任务的添加

##### 2 核心线程会被回收吗？

​	正常情况下不会被回收

​	但是两种情况会被销毁重建：

​	（1）allowCoreThreadTimeOut参数 ，这个如果为true ，则会给核心线程数设置超时等待时间 ，如果超过时间了就会销毁。

​	（2）当我们实现Runnable的run方法，出现异常，会销毁重建。

##### 3 非核心线程什么时候会被回收

​	非核心线程闲置时的超时时长，超过这个时长，非核心线程就会被回收







#### 未完待续



## 五、Android三种动画

### 1 View Animation（视图动画）

​	平移动画（TranslateAnimation）缩放动画（ScaleAnimation）旋转动画（RotateAnimation）透明度动画（AlphaAnimation）

### 2 Drawable Animation（帧动画）

​	onCreate 中，findViewById 之后添加动画，部分手机可能 onCreate 方法没有执行完，imageView  对象就不会真正的实例化出来，这就到导致空指针异常（NullPointException）。正确的使用方法，根据活动的运行周期，我们应该在  onResume 方法中添加它，这样就保证了所有的控件都被实例化出来

### 3 Property Animation（属性动画）





## 六、View

![view1](https://raw.githubusercontent.com/ilnaygniy/picBed/master/view1.png)

![](https://raw.githubusercontent.com/ilnaygniy/picBed/master/view1.jpg)



View 的生命周期为

 [改变可见性] --> 构造View --> onFinishInflate -->  onAttachedToWindow --> onMeasure -->  onSizeChanged -->  onLayout --> onDraw -->

View的绘制基本由measure()、layout()、draw()这个三个函数完成

### 1 OnMeasure（）

​	测量视图大小。从顶层父View到子View递归调用measure方法，measure方法又回调OnMeasure。

​	

### 2 OnLayout()

​	确定View位置，进行页面布局。从顶层父View向子View的递归调用view.layout方法的过程，即父View根据上一步measure子View所得到的布局大小和布局参数，将子View放在合适的位置上。

### 3 OnDraw()

![20180507141255495](https://raw.githubusercontent.com/ilnaygniy/picBed/master/20201209110331.png)

​	绘制视图。ViewRoot创建一个Canvas对象，然后调用OnDraw()。六个步骤：①、绘制视图的背景；②、保存画布的图层（Layer）；③、绘制View的内容；④、绘制View子视图，如果没有就不用； ⑤、还原图层（Layer）；⑥、绘制滚动条。

### 4 事件分发

本质：将点击屏幕产生的MotionEvent对象传递到某个具体的View然后处理消耗这个事件的整个过程。

事件分发流程图：

![touch](https://raw.githubusercontent.com/ilnaygniy/picBed/master/touch.png)



### 5 ViewGroup绘制过程

​	![viewgroup](https://raw.githubusercontent.com/ilnaygniy/picBed/master/20201120145107.jpg)



​		





#### 未完待续

## 七、Service

### 1 服务分类

#### 1.1 前台服务

​	前台服务就像平时我们播放音乐的时候通知栏会有一个常驻的通知，然后后台播放歌曲，那个就是前台服务

#### 1.2 后台服务

​	后台服务一般我们感受不到，他在后台默默为前台服务，提供数据运算等等。例如当我们使用微信返回桌面的时候，还是可以接受信息，这个就是服务的作用

### 2 启动方式

![service1](https://raw.githubusercontent.com/ilnaygniy/picBed/master/service1.png)

#### 2.1 直接启动

```java
Intent intent = new Intent(this,MyService.class);
startService(intent);
```

每个服务只能被创建一次，也就onCreate方法只会执行一次。多次使用startService去启动同一个服务，只会重复执行onStartCommand方法，而不会再次执行onCreate方法，因为只能Service只能存在一个实例

#### 2.2 绑定服务

```java
private MyService.MyBinder binder;

ServiceConnection connection = new ServiceConnection() {
            @Override
            public void onServiceConnected(ComponentName name, IBinder service) {
                binder = (MyService.MyBinder)service;
            }
            @Override
            public void onServiceDisconnected(ComponentName name) {
            }
        };

Intent intent = new Intent(this,MyService.class);
bindService(intent, connection, BIND_AUTO_CREATE);
```

Intent容易理解，和直接启动服务一样。最后的int类型参数，是一个flag标志，BIND_AUTO_CREATE的数值是1 ，表示绑定的时候顺带创建服务，并调用onCreate方法，一般情况下传入这个参数即可。
第二个参数Connection是一个ServiceConnection对象，这个对象可以通过匿名类来创建，主要重写两个方法。第一个方法是绑定成功之后要做的事情，会返回一个IBinder参数，这个IBinder参数就是服务中的onBinder方法返回的数据。通过这个IBinder就可以调用服务中的方法了。

另外，当一个活动已经绑定了这个服务，另外一个活动柜再次绑定这个服务的时候，不会再调用服务的onCreate方法，而是会把同一个IBinder参数再返回，也就是两个活动拿到同一个IBinder对象。

### 3 与线程的区别

Thread：Thread 是程序执行的最小单元，它是分配CPU的基本单位。可以用 Thread 来执行一些异步的操作。

Service：Service 是android的一种机制，是Android四大组件之一

Service并不是运行在子线程的，而是运行在主线程，所以不能直接在服务中执行耗时的逻辑，不然就会产生ANR。因而每个耗时的逻辑都应该在子线程中执行。

### 4 如何保证Service不被杀死

**1. onStartCommand方式中，返回START_STICKY**

**2.提高Service的优先级**

​	在AndroidManifest.xml文件中对于intent-filter可以通过android:priority = "1000"这个属性设置最高优先级，1000是最高值，如果数字越小则优先级越低，同时适用于广播。

**3.提升Service进程的优先级**

当系统进程空间紧张时，会依照优先级自动进行进程的回收。
 Android将进程分为6个等级，按照优先级由高到低依次为：

- 前台进程foreground_app
- 可视进程visible_app
- 次要服务进程secondary_server
- 后台进程hiddena_app
- 内容供应节点content_provider
- 空进程empty_app
   可以使用startForeground将service放到前台状态，这样低内存时，被杀死的概率会低一些。

**4.在onDestroy方法里重启Service**
 当service走到onDestroy()时，发送一个自定义广播，当收到广播时，重新启动service。

**5.系统广播监听Service状态**

**6.将APK安装到/system/app，变身为系统级应用**



### 5 与IntentService

​	Service不是独立的进程，也不是独立的线程，它是依赖于应用程序的主线程的

​	IntentService是继承Service的，那么它包含了Service的全部特性，当然也包含service的生命周期。

​	那么与service不同的是，IntentService在执行onCreate操作的时候，内部开了一个线程，去执行耗时操作

​	IntentService:异步处理服务，新开一个线程：handlerThread在线程中发消息，然后接受处理完成后，会清理线程，并且关掉服务。

IntentService有以下特点：

（1）  它创建了一个独立的工作线程来处理所有的通过onStartCommand()传递给服务的intents。

（2）  创建了一个工作队列，来逐个发送intent给onHandleIntent()。

（3）  不需要主动调用stopSelft()来结束服务。因为，在所有的intent被处理完后，系统会自动关闭服务。

（4）  默认实现的onBind()返回null

（5）  默认实现的onStartCommand()的目的是将intent插入到工作队列中



6 







## 八、Glide

```
Glide.with(content)
     .load(url)
     .into(imageView);
with绑定生命周期，load指定加载资源，into指明加载目标
```

### 1 图片加载策略

![798986-20200715210707581-394777567](https://raw.githubusercontent.com/ilnaygniy/picBed/master/20210104162337.png)

## 九 Fragment

​	**Fragment必须总是被嵌入到一个Activity之中**，并且Fragment的生命周期直接受其宿主Activity的生命周期的影响。可以认为Fragment是Activity的一个模块零件，它有自己的生命周期，接收它自己的输入事件，并且可以在Activity运行时添加或者删除。



# 补充在这里，慢慢添加Android相关

# ------分割线-------





# JAVA相关

## 一  JVM

### 1 JVM内存区域划分

![](https://raw.githubusercontent.com/ilnaygniy/picBed/master/jvm.webp)



#### 1.1 程序计数器

​	由于JVM中，多线程是通过轮流切换来获得CPU执行时间，因此在任一具体时刻，一个CPU的内核只会执行一条线程中的指令，为了使每个线程都在线程切换后能够恢复在切换之前的程序执行位置，每个线程需要有自己独立的程序计数器，并且互不干扰，因此程序计数器是每个线程私有。



#### 1.2  JAVA虚拟机栈

​	Java虚拟机栈也是线程私有，生命周期和线程相同。每个方法在执行的时候都会创建一个栈帧用于储存局部变量表、操作数栈、动态链接、方法出口等信息。

​	在Java虚拟机规范中，对这个区域规定了两种异常情况：如果线程请求的栈深度大于虚拟机锁允许的深度，将抛出StackOverflowError异常，如果虚拟机栈可以动态扩展(),如果扩展时无法申请到足够的内存，就睡抛出OutOfMemeoryError异常，也就是OOM异常.



#### 3 本地方法栈

​	本地方法栈与虚拟机栈所发挥的所用非常相似，区别是虚拟机栈为虚拟机执行Java方法(也就是字节码)服务，而本地方法栈则为虚拟机用的Native方法服务。

​	与虚拟机栈一样，本地方法栈预期也会抛出StackOverflowError和OutOfMemoryError异常。



#### 4 JAVA 堆

​	java虚拟机所管理内存中最大的一块，java堆是被所有线程共享的一块内存区域，此内存区域的唯一目的就是存放对象实例。几乎所有的对象实例都在这里分配内存

​	所有的对象实例以及数组都要在堆上分配，但是随着JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐不是那么绝对了。



#### 5 方法区

​	方法区与java堆一样是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

##### 	运行常量池

​	是方法区的一部分。用于存放编译期生成的各种字面量和符号引用，这部分内容在类加载后进入方法区的运行时常量池中存放。

### 2 栈内存、堆内存

​		Java把内存分成两种，一种叫做栈内存，一种叫做堆内存。

​		栈内存：在函数中定以基本类型的变量和对象的引用变量都是在函数的**栈内存**中分配。当一段代码定以一个变量时，java就在**栈**中为这个变量分配内存空间，当超过变量的作用域后，java会自动释放掉为该变量分配的内存空间，该内存空间可以立刻被另作他用。

​		堆内存：堆内存用于存放由new创建的对象和数组。在堆中分配的内存，由java虚拟机自动垃圾回收器来管理。在堆中产生一个数组或对象后，可以在栈中定义一个特殊变量，这个变量取值为对象在堆内存中的首地址，在栈中这个特殊变量就变成堆中数组或者对象的引用变量。以后就可以在程序中使用栈内存中的引用变量来访问堆中的数组或者对象。

**栈与堆都是Java用来在Ram中存放数据的地方。与C++不同，Java自动管理栈和堆，程序员不能直接地设置栈或堆。**

#### 1 内存分配策略

​	内存分配三种策略：静态的、栈式的、堆式的

#### 2 堆和栈比较

​	堆主要用来存放对象的，栈主要是用来执行程序的

#### **3 JVM中的堆和栈**

​	JVM是基于堆栈的虚拟机.JVM为每个新创建的线程都分配一个堆栈.也就是说,对于一个Java程序来说，它的运行就是通过对堆栈的操作来完成的。堆栈以帧为单位保存线程的状态。JVM对堆栈只进行两种操作:以帧为单位的压栈和出栈操作。

每一个Java应用都唯一对应一个JVM实例，每一个实例唯一对应一个堆。



### 3 垃圾回收机制

何为垃圾：Java中那些不可达的对象就会变成垃圾。

1.对非线程对象来说，所有的活动线程都不能访问该对象，那么该对象就会变为垃圾。
2.对线程对象来说，满足上面的条件，且线程未启动或者已停止。

回收依据：

方法一：引用计数法。简单但速度很慢。缺陷是：不能处理循环引用的情况。一般不用。

方法二：停止-复制(stop and copy)。效率低，需要的空间大，优点，不会产生碎片。

方法三：标记 - 清除算法 (mark and sweep)。速度较快，占用空间少，标记清除后会产生大量的碎片。

方法四：标记-压缩算法。标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清				理掉端边界以外的内存。

方法五：分代收集算法，把Java堆分为新生代和老生代，根据各个年代的特点采用最合适的算法。



### 4 类加载过程

一个类被加载到虚拟机内存中需要经历几个过程：**加载、连接、初始化**，其中**连接**分为三个步骤：**验证、准备、解析**。

类加载器包括 BootClassLoader、ExtClassLoader、APPClassLoader

#### 1 加载

加载过程主要分三步：

1.1 获取一个类的二进制字节流。把类以流的形式加载进内存（来源可以是jar、class、apk文件）。这个特性是能够实现插件化技术的理论基础。

1.2 获取字节流后，虚拟机会把类中的静态存储结果保存到方法区中，保存过程会转化对应方法区的数据结构。所以说静态的结构都保存在内存中的方法区中。

1.3 当类加载到内存中后，每个类生成一个对应的Class对象，使用这个类的时候都是通过此Class对象为入口来使用的。比如new一个类对象，也是通过Class



#### 2 连接

连接主要分验证、准备、解析。

2.1 验证：主要对类中的语法结构是否合法进行验证，确认是否符合java语言语义。

2.2 准备：这个阶段给类中的变量分配内存，设置默认初始值。int=0等。

2.3 解析：在类型的常量池中寻找类的接口，字段和方法的符号引用，把这些符号引用替换成直接引用的过程。



#### 3 初始化

初始化阶段才真正到了类中定义的java代码的阶段。

初始化不会马上执行，当一个类被主动使用的时候才会去初始化：

1 当创建某个类的新实例时（new、反射）。

2 当调用某个类的静态方法时。

3 当使用某个类或接口的静态字段时。

4 当调用Java API中的某些反射方法时。

5 当初始化某个子类时。



未完待续







### 5 内部类

https://blog.csdn.net/xueyoubangbang/article/details/83106020

#### 1 static静态修饰符

statci修饰表示静态的，在类加载时JVM会把它放在方法区，被本类以及本类所有实例所公用。在编译后所分配的内存会一直存在，直到程序退出时才会释放这个空间。如果被所有实例公用的方法被申明为static，那么就可以节省空间了，不用每个实例初始化的时候都被分配到内存。



#### 2 内部类

（1）作用：

- 更好的封装性
- 内部类成员可以直接访问外部类的私有数据，因为内部类被当成其外部类成员，但外部类不能访问内部类的实现细节，例如内部类的成员变量
- 匿名内部类适合用于创建那些仅需要一次使用的类

（2）静态 or 非静态

- 是否能拥有静态成员 ：静态内部类可以有静态成员(方法，属性)，而非静态内部类则不能有静态成员(方法，属性)。 
- 访问外部类的成员 ：静态内部类只能够访问外部类的静态成员,而非静态内部类则可以访问外部类的所有成员(方法，属性)。 
- 静态内部类和非静态内部类在创建时有区别：

```
//假设类A有静态内部类B和非静态内部类C，创建B和C的区别为： 
 A a=new A(); 
 A.B b=new A.B(); 
 A.C c=a.new C();
```

**静态内部类的对象不持有外部类的引用，非静态内部了持有外部类的引用**







## 二 HashMap

### 1 底层结构

​	Java7中，链表+数组

​	Java8中，链表+数组+红黑树（当链表中元素超过8个时，才会将链表转为红黑树）

​	![hashmap1](https://raw.githubusercontent.com/ilnaygniy/picBed/master/hashmap1.jpg)



#### 1.1HashMap的实现原理

​	HashMap的主干是一个Entry数组。Entry是HashMap的基本组成单元，每一个Entry包含一个key-value键值对。

​	**HashMap由数组+链表组成的**，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在。如果定位到的数组位置不含链表（当前entry的next指向null）,那么查找，添加等操作很快，仅需一次寻址即可；如果定位到的数组包含链表，对于添加操作，其时间复杂度为O(n)，首先遍历链表，存在即覆盖，否则新增；对于查找操作来讲，仍需遍历链表，然后通过key对象的equals方法逐一比对查找。所以，性能考虑，**HashMap中的链表出现越少，性能才会越好。**

#### 1.2 扩容

​	1 负载因子默认为0.75，当map填满75%的时候，将会创建原来HashMap大小两倍的bucket数组，来调整map的大小，将原来的对象放入新的bucket数组中。

​	2 当重新调整hashmap大小的时候，会存在竞争条件，当两个线程都发现hashmap需要调整大小，它们会同时试着调整大小。在调整大小的过程中，存储在链表中的元素的次序会反过来，因为移动到新的bucket位置的时候，HashMap并不会将元素放在链表的尾部，而是放在头部，这是为了避免尾部遍历(tail traversing)。如果条件竞争发生了，那么就死循环了。(多线程的环境下不使用HashMap）。

#### 1.3HashMap的数组长度一定是2的次幂

		原因：当数组长度不为2的n次幂 的时候，hashCode 值与数组长度减一做与运算 的时候，会出现重复的数据，因为不为2的n次幂 的话，对应的二进制数肯定有一位为0 ,这样，不管你的hashCode 值对应的该位，是0还是1 ,最终得到的该位上的数肯定是0，这带来的问题就是HashMap上的数组元素分布不均匀，而数组上的某些位置，永远也用不到。
#### 1.4Hashtable、HashMap、ConcurrentHashMap

​	1 Hashtable是线程安全的，能用于多线程环境中；HashMap多线程环境不使用；Hashtable 中的方法是Synchronize的，而HashMap中的方法在缺省情况下是非Synchronize的

​	2 Hashtable继承自Dictionary类，而HashMap继承自AbstractMap类。但二者都实现了Map接口。

​	3 Hashtable中，**key和value都不允许出现null值**，HashMap中，**null可以作为键**，这样的键只有一个；

​	4 HashMap把Hashtable的contains方法去掉了，改成containsValue和containsKey； Hashtable则保留了contains，containsValue和containsKey三个方法，其中contains和containsValue功能相同

​	5 两个遍历方式： Hashtable、HashMap都使用了 Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式 

​	6 哈希值的使用不同，HashTable直接使用对象的hashCode。而HashMap重新计算hash值

​	7  HashTable在不指定容量的情况下的默认容量为11，而HashMap为16，Hashtable不要求底层数组的容量一定要为2的整数次幂，而HashMap则要求一定为2		的整数次幂。
  	 Hashtable扩容时，将容量变为原来的2倍加1，而HashMap扩容时，将容量变为原来的2倍。

   	Hashtable和HashMap它们两个内部实现方式的数组的初始大小和扩容的方式。HashTable中hash数组默认大小是11，增加的方式是 old*2+1。



​	8 ConcurrentHashMap(线程安全)，底层数组+链表，Hashtable整张Hash表synchronized，读取慢，ConcurrentHashMap**锁分离**（数据分成默认16段）技术，允许多个修改操作并	    发进行，读取快

#### 1.5 HashCode 、equals

 	1.equal()相等的两个对象他们的hashCode()肯定相等，也就是用equal()对比是绝对可靠的。

​     2.hashCode()相等的两个对象他们的equal()不一定相等，也就是hashCode()不是绝对可靠的,有时候不同的对象他们生成的hashcode也会一样（生成hash值得公式可能存在的问题)。





## 三 字符串String、数组、数据类型转换

### 1 字符串String

#### 	1.1 实例化String

​	（1）直接赋值，如：String str="hello";

​	（2）使用关键字 new，如：String str=new String("hello");

![](https://raw.githubusercontent.com/ilnaygniy/picBed/master/String1.png)

​	使用 new 的方式在堆内存中开辟了两个空间，

　　第一个 "hello"，对象 str 没有指向，无用等待回收，

　　第二个 "hello"，被 str 指向，有用。

​	所以 直接赋值（只开辟了一个空间） 的方式更常用和合理，可以节省一些空间。



字符串的内容不可更改，如

![](https://raw.githubusercontent.com/ilnaygniy/picBed/master/String2.png)

#### 	1.2 StringBuffer

​	为什么有的时候要用StringBuffer，而不用String：

​	String是不可变的，所以要对String作改动不能直接改那个String本身，而是要创建新的String，所以如果改动次数多，用String就效率不高，而StringBuffer（如果是单线程则建议用StringBuilder，不用考虑线程安全性，效率更高点）

#### 	1.3 StringBuilder

​	一个可变的字符序列，该类被设计作用StringBuffer的一个简易替换，用在字符串缓冲区被单个线程使用的时候，建议优先考虑该类，速度比StringBuffer要快

   但如果涉及到线程安全方面，建议使用StringBuffer



### 2 数组

​	引用类型，必须开辟控件（new ），可引用传递





## 四 多线程

### 1 线程与进程

​	**进程：**是代码在数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位。多进程操作系统由于CPU具备分时机制，所以每个进程都能循环获得自己的CPU时间片。对于多CPU，多个进程可以并行在多个cpu中计算，当然也会存在进程切换。同一进程同一时间段只能在一个cpu中运行，进程数小于cpu数，未使用的cpu将会空闲

​	**线程：**是进程的一个执行路径，一个进程中至少有一个线程，进程中的多个线程共享进程的资源。对于多核cpu，进程中的多线程并行执行。对于单核cpu，多线程在单cpu中并发执行，根据时间片切换线程。同一个线程同一时间段只能在一个cpu内核中运行，如果线程数小于cpu内核数，那么将有多余的内核空闲。

**二者关系：**

一个进程中有多个线程，多个线程共享进程的堆和方法区资源，但是每个线程有自己的程序计数器和栈区域。

**二者区别：**

​	**进程**：有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响。

​	**线程**：是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉。



### 2 并发与并行

​	**并发：**是指同一个时间段内多个任务同时都在执行，并且都没有执行结束。并发任务强调在一个时间段内同时执行，而一个时间段由多个单位时间累积而成，所以说并发的多个任务在单位时间内不一定同时在执行 。

​	**并行**：是说在单位时间内多个任务同时在执行 。

​	在多线程编程实践中，线程的个数往往多于CPU的个数，所以一般都称多线程并发编程而不是多线程并行编程。







## 五 JAVA集合











## 六 Java的四种引用方式

### 1 强引用

​	强引用有引用变量指向时永远不会被垃圾回收，jvm宁愿抛出OutOfMemory也不会回收这种对象。

```
String str = "hello";    // 强引用
str = null;              // 取消强引用
```

### 2 软引用

​	如果对象具有软引用，内存空间足够，垃圾回收器就不会回收它。只要垃圾回收器没有回收它，该对象就可以被程序使用。

```
SoftReference<String> softName = new  SoftReference<>("string字符串");
```

​	应用：可用来实现内存敏感的高速缓存,比如网页缓存、图片缓存等。

### 3 弱引用

​	JVM进行垃圾回收时，无论当前内存空间是否充足，**都会将弱引用回收**，不过垃圾回收器是一个优先级较低的线程，所以并不一定能迅速发现弱引用对象。

```
WeakReference<String> weakName = new WeakReference<String>("hello");
```

### 4 虚引用

​	如果一个对象仅持有虚引用，那么它相当于没有引用，在**任何时候都可能被垃圾回收器回收**。

​	虚引用必须和引用队列关联使用，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。

```
ReferenceQueue<String> queue = new ReferenceQueue<String>();
PhantomReference<String> pr = new PhantomReference<String>(new String("hello"), queue);
```



## 七 设计模式

### 1 设计模式类型

#### 创建型模型

​	这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。　　

​	1. 工厂模式（Factory Pattern）

​	2. 抽象工厂模式（Abstract Factory Pattern） 

​	3. 单例模式（Singleton Pattern）

​	4. 建造者模式（Builder Pattern）

​	5. 原型模式（Prototype Pattern）

#### 结构性模式

　　这些设计模式关注类和对象的组合。	

​	6. 适配器模式（Adapter Pattern）

​	7. 桥接模式（Bridge Pattern）

​	8. 过滤器模式（Filter、Criteria Pattern）

	9. 组合模式（Composite Pattern）
	10. 装饰器模式（Decorator Pattern）
	11. 外观模式（Facade Pattern）
	12. 享元模式（Flyweight Pattern）
	13. 代理模式（Proxy Pattern）

#### 行为型模式

　　这些设计模式关注对象之间的行为关系（交互，通信）

14. 责任链模式（Chain of Responsibility Pattern）
15. 命令模式（Command Pattern）
16. 解释器模式（Interpreter Pattern）
17. 迭代器模式（Iterator Pattern）
18. 中介者模式（Mediator Pattern）
19. 备忘录模式（Memento Pattern）
20. 观察者模式（Observer Pattern）
21. 状态模式（State Pattern）
22. 空对象模式（Null Object Pattern）
23. 策略模式（Strategy Pattern）
24. 模板模式（Template Pattern）
25. 访问者模式（Visitor Pattern）

#### J2EE模式

　　这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。

MVC 模式（MVC Pattern）

业务代表模式（Business Delegate Pattern）

组合实体模式（Composite Entity Pattern）

数据访问对象模式（Data Access Object Pattern）

前端控制器模式（Front Controller Pattern）

拦截过滤器模式（Intercepting Filter Pattern）

服务定位器模式（Service Locator Pattern）

传输对象模式（Transfer Object Pattern）



### 2 六大基本原则

​	设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。

#### 1.1 单一职责原则

​	一个类只负责一个功能领域中的相应职责。或者可以定以为：就一个类而言，应该只有一个引起它变化的原因。

#### 1.2 里氏替换原则

​	定义：所有引用基类的地方必须能透明地使用其子类的对象。就是父类能出现的地方子类就可以出现，但是反过来就不行了。子类可以扩展父类的功能，但不能改变父类原有的功能。

#### 1.3 依赖倒置原则

​	依赖倒置原则可以减少类之间的耦合性，提高系统的稳定性；降低并行开发引起的风险。

1. 高层模块不应该依赖低层模块
2. 抽象不应该依赖细节
3. 细节依赖抽象

　**抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。**

​	Java中表现为：面向接口编程OOP

#### 1.4 接口隔离原则

​	使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些他不需要的接口。

#### 1.5 开闭原则

​	一个实体应当对扩展开放，对修改关闭。集软件实体应尽量在不修改原有代码的情况下进行扩展。

#### 1.6 迪米特法则（最少知识原则）

​	一个实体应当尽可能少的与其他实体发生相互作用。





## 八  Java锁

### 1 公平锁/非公平锁

​	**公平锁**是指多个线程按照申请锁定顺序来获取锁

​	**非公平锁**是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的优先获取。有可能会造成优先级反转或者饥饿现象。

​	对于Java `ReentrantLock`而言，通过构造函数指定该锁是否是公平锁，默认是非公平锁。**非公平锁的优点在于吞吐量比公平锁大**。

​	对于`Synchronized`而言，也是一种非公平锁。由于其并不像`ReentrantLock`是通过AQS的来实现线程调度，所以并没有任何办法使其变成公平锁。



### 2 可重入锁

​	可重入锁又名递归锁，是指在同一线程在外层方法获取锁的时候，在进入内层会自动获取锁。

​	对于Java `ReentrantLock`而言, 他的名字就可以看出是一个可重入锁，其名字是`Re entrant Lock`重新进入锁。

​	对于`Synchronized`而言,也是一个可重入锁。可重入锁的一个好处是**可一定程度避免死锁**。





### 3 互斥锁/读写锁

​	互斥锁：在访问资源之前加锁，在访问完成之后解锁。加锁后其他试图再次加锁的线程会被阻塞，直到当前进程解锁。

​	读写锁：既是互斥锁，又是共享锁，read模式是共享，write是互斥(排它锁)的。读写锁有三种状态，读加锁状态、写加锁状态、不加锁状态。一次只有一个线程可以占有写模式的读写锁，但是多个线程可以同时占有读模式的读写锁。**读写锁在Java中的具体实现就是** ReadWriteLock



### 4 乐观锁/悲观锁

​	悲观锁：每次拿数据都会上锁。共享资源每次都只给一个线程使用，其他线程阻塞。Java中的synchronized和ReentrantLock等独占锁就是悲观锁思想实现的。

​	乐观锁：每次拿数据都不会上锁，在更新的时候会判断下在此期间别人有没有去更改数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，可以提高吞吐量，在Java中`java.util.concurrent.atomic`包下面的原子变量类就是使用了乐观锁的一种实现方式CAS（compare and swap（比较与交换）实现的。



### 5 锁分解/锁分段

在并发程序中，对可伸缩性的最主要威胁就是独占方式的资源锁。

降低锁的竞争度：

​	1 减少锁持有时间

​	2 降低锁请求频率

​	3 使用带有协调机制的独占锁，这些机制允许更高的并发性

**锁分解、锁分段技术能降低线程的请求锁频率。**

**锁分解：**

```
public synchronized void method(){map.add(obj);}
```

优化后：

```
public void method(){
    synchronized (obj){
        map.add(obj);
    }
}
```

 **锁分解技术只适用于在锁上存在适中而不是激烈的竞争时，**



**锁分段：**

​	在某些情况下，可以将锁分解技术进一步扩展为对一组独立对象上的锁进行分解，这种情况被称为锁分段。如jdk1.8之前的concurrentHashMap。ConcurrentHashMap中有16个锁的数组，每个锁保护一个数组，16个数组彼此独立。



锁分段的劣势：

​	与单个锁来实现独占访问相比，要获取多个锁来实现独占访问将更加困难并且开销更高。通常，在执行一个操作时最多只需获取一个锁，但在某些情况下需要加锁整个容器。例如当ConcurrentHashMap需要扩展映射范围，以及重新计算键值的散列值要分不到更大的桶集合中时，就需要获取分段所有集合中的所有锁。

### 6 偏向锁/轻量级锁/重量级锁

​	**重量级锁**：内置锁在Java中被抽象为监视器锁（monitor）。在JDK 1.6之前，监视器锁可以认为直接对应底层操作系统中的互斥量（mutex）。这种同步方式的成本非常高，包括系统调用引起的内核态与用户态切换、线程阻塞造成的线程切换等。因此，后来称这种锁为“重量级锁”。

​	**轻量级锁**：自旋锁的目标是降低线程切换的成本。如果锁竞争激烈，我们不得不依赖于重量级锁，让竞争失败的线程阻塞；如果完全没有实际的锁竞争，那么申请重量级锁都是浪费的。**轻量级锁的目标是，减少无实际竞争情况下，使用重量级锁产生的性能消耗**，包括系统调用引起的内核态与用户态切换、线程阻塞造成的线程切换等。

​		 缺点：同自旋锁相似：如果*锁竞争激烈*，那么轻量级将很快膨胀为重量级锁，那么维持轻量级锁的过程就成了浪费。

​	**偏向锁**：在没有实际竞争的情况下，还能够针对部分场景继续优化。如果不仅仅没有实际竞争，自始至终，使用锁的线程都只有一个，那么，维护轻量级锁都是浪费的。**偏向锁的目标是，减少无竞争且只有一个线程使用锁的情况下，使用轻量级锁产生的性能消耗**。轻量级锁每次申请、释放锁都至少需要一次CAS，但偏向锁只有初始化时需要一次CAS。



偏向锁、轻量级锁、重量级锁适用于不同的并发场景：

- 偏向锁：无实际竞争，且将来只有第一个申请锁的线程会使用锁。
- 轻量级锁：无实际竞争，多个线程交替使用锁；允许短时间的锁竞争。
- 重量级锁：有实际竞争，且锁竞争时间长。

### 7 自旋锁

​	自旋锁：是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断地判断锁是否能够被获取成功，知道获取成功后才会退出循环。获取锁的线程一直处于活跃状态，但并没有执行任何有效任务，使用这种锁会造成busy-waiting。

​	缺点：

​	1  单核处理器上，不存在实际的并行，当前线程不阻塞自己的话，旧owner就不能执行，锁永远不会释放，此时不管自旋多久都是浪费；进而，如果线程多而处理器少，自旋也会造成不少无谓的浪费。

​	2  自旋锁要占用CPU，如果是计算密集型任务，这一优化通常得不偿失，减少锁的使用是更好的选择。

​	3  如果锁竞争的时间比较长，那么自旋通常不能获得锁，白白浪费了自旋占用的CPU时间。这通常发生在*锁持有时间长，且竞争激烈*的场景中，此时应主动禁用自旋锁。





## 九 Java九大排序算法

### 1 算法结构图

![11](https://raw.githubusercontent.com/ilnaygniy/picBed/master/20201223110005.jpg)

### 2 算法性能对比

![Dingtalk_20201223110153](https://raw.githubusercontent.com/ilnaygniy/picBed/master/20201223110203.jpg)



### 3 算法步骤

#### 1 直接插入排序

1. 从第一个元素开始，该元素可以认为已经被排序
2. 取出下一个元素，在已经排序的元素序列中从后向前扫描
3. 如果该元素（已排序）大于新元素，将该元素移到下一位置
4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置
5. 将新元素插入到该位置后
6. 重复步骤2~5

```java
/**
 * 通过交换进行插入排序，借鉴冒泡排序
 *
 * @param a
 */
public static void sort(int[] a) {
    for (int i = 0; i < a.length - 1; i++) {
        for (int j = i + 1; j > 0; j--) {
            if (a[j] < a[j - 1]) {
                int temp = a[j];
                a[j] = a[j - 1];
                a[j - 1] = temp;
            }
        }
    }
}

/**
 * 通过将较大的元素都向右移动而不总是交换两个元素
 *
 * @param a
 */
public static void sort2(int[] a) {
    for (int i = 1; i < a.length; i++) {
        int num = a[i];
        int j;
        for (j = i; j > 0 && num < a[j - 1]; j--) {
            a[j] = a[j - 1];
        }
        a[j] = num;
    }
}
```



#### 2 希尔排序

希尔排序，也称 **递减增量排序算法**，是插入排序的一种更高效的改进版本。希尔排序是 **非稳定排序算法**

希尔排序是基于插入排序的以下两点性质而提出改进方法的：

- 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率
- 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一

希尔排序是先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。



##### 未理解

#### 3 选择排序

原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。

```java
public static void sort(int[] a) {
    for (int i = 0; i < a.length; i++) {
        int min = i;
        //选出之后待排序中值最小的位置
        for (int j = i + 1; j < a.length; j++) {
            if (a[j] < a[min]) {
                min = j;
            }
        }
        //最小值不等于当前值时进行交换
        if (min != i) {
            int temp = a[i];
            a[i] = a[min];
            a[min] = temp;
        }
    }
}
```



#### 4 堆排序

##### 	未理解



#### 5 快速排序

快速排序使用分治法策略来把一个串行分为两个子串行。是处理大数据最快的排序算法之一。

快速排序使用分治策略来把一个序列（list）分为两个子序列（sub-lists）。步骤为：

1. 从数列中挑出一个元素，称为"基准"（pivot）。
2. 重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。
3. 递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。

用伪代码描述如下：

1. `i = L; j = R;` 将基准数挖出形成第一个坑`a[i]`。
2. `j--`，由后向前找比它小的数，找到后挖出此数填前一个坑`a[i]`中。
3. `i++`，由前向后找比它大的数，找到后也挖出此数填到前一个坑`a[j]`中。
4. 再重复执行2，3二步，直到`i==j`，将基准数填入`a[i]`中。



## 十 树、二叉树

### 1 树

#### 1.1 树定义

​	树是n（n>=0）个节点的有限集。n=0时称为空树。在任意一颗非空树中：

​	（1）有且仅有一个特定的成为根的结点；

​	（2）当n>1时，其余结点可分为m（m>0）个互不相交的有限集T1、T2、......、Tn，其中每一个集合本身又是一棵树，称为根的子树。

​	n>0时根结点是唯一的，m>0时，子树的个数没有限制，但它们一定是互不相交的。

#### 1.2 结点的度

![Dingtalk_20201208154633](https://raw.githubusercontent.com/ilnaygniy/picBed/master/20201208154652.jpg)



 结点子树的根结点为该结点的**孩子结点**。相应该结点称为孩子结点的**双亲结点**。
 A为B的双亲结点，B为A的孩子结点。
 同一个双亲结点的孩子结点之间互称**兄弟结点**。
 结点B与结点C互为兄弟结点。

如图：4层，深度为4

### 2 二叉树

**1 特点：**

```
1）每个结点最多有两颗子树，所以二叉树中不存在度大于2的结点。
2）左子树和右子树是有顺序的，次序不能任意颠倒。
3）即使树中某结点只有一棵子树，也要区分它是左子树还是右子树。
```



**2 性质：**

1）在二叉树的第i层上最多有2i-1 个节点 。（i>=1）
2）二叉树中如果深度为k,那么最多有2k-1个节点。(k>=1）
3）n0=n2+1 n0表示度数为0的节点数，n2表示度数为2的节点数。
4）在完全二叉树中，具有n个节点的完全二叉树的深度为[log2n]+1，其中[log2n]是向下取整。
5）若对含 n 个结点的完全二叉树从上到下且从左至右进行 1 至 n 的编号，则对完全二叉树中任意一个编号为 i 的结点有如下特性：

> (1) 若 i=1，则该结点是二叉树的根，无双亲, 否则，编号为 [i/2] 的结点为其双亲结点;
> (2) 若 2i>n，则该结点无左孩子， 否则，编号为 2i 的结点为其左孩子结点；
> (3) 若 2i+1>n，则该结点无右孩子结点， 否则，编号为2i+1 的结点为其右孩子结点。



**3 斜树**

所有的结点都只有左子树的二叉树叫左斜树。

所有的结点都只有右子树的二叉树叫右斜树。

**4 满二叉树**

在一棵二叉树中。如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树。

**5 完全二叉树**

对一颗具有n个结点的二叉树按层编号，如果编号为i(1<=i<=n)的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树。

**特点**：
1）叶子结点只能出现在最下层和次下层。
2）最下层的叶子结点集中在树的左部。
3）倒数第二层若存在叶子结点，一定在右部连续位置。
4）如果结点度为1，则该结点只有左孩子，即没有右子树。
5）同样结点数目的二叉树，完全二叉树深度最小。
**注**：满二叉树一定是完全二叉树，但反过来不一定成立。



6 二叉树存储结构

（1）顺序存储：一般只用于完全二叉树

![img](https://raw.githubusercontent.com/ilnaygniy/picBed/master/20210118155250.png)

将这棵二叉树存入到数组中，相应的下标对应其同样的位置：

![img](https://raw.githubusercontent.com/ilnaygniy/picBed/master/20210118155320.png)

（2）二叉链表

![img](https://raw.githubusercontent.com/ilnaygniy/picBed/master/20210118155344.png)

### 3 二叉树遍历

**二叉树的遍历**是指从二叉树的根结点出发，按照某种次序依次访问二叉树中的所有结点，使得每个结点被访问一次，且仅被访问一次。
二叉树的访问次序可以分为四种：

> 前序遍历:从二叉树的根结点出发，按照某种次序依次访问二叉树中的所有结点，使得每个结点被访问一次，且仅被访问一次 
> 中序遍历:就是从二叉树的根结点出发，当第二次到达结点时就输出结点数据，按照先向左在向右的方向访问。 
> 后序遍历:从二叉树的根结点出发，当第三次到达结点时就输出结点数据，按照先向左在向右的方向访问。
> 层序遍历:按照树的层次自上而下的遍历二叉树

![img](https://raw.githubusercontent.com/ilnaygniy/picBed/master/20210118150007.png)



(1) 前序遍历

输出为：**ABDHIEJCFG**

(2) 中序遍历

输出为：**HDIBJEAFCG**

(3)后序遍历

输出为：**HIDJEBFGCA**

(4)层序遍历

输出为：**ABCDEFGHIJ**

https://blog.csdn.net/yanwenyuan0304/article/details/95233918





# ------分割线-------

# 网络相关

## 一 HTTP & HTTPS

### 1 HTTP 

​	HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）

#### 1.1 HTTP 三点注意事项

​	1 HTTP是无连接：无连接含义是限制每次链接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。节省时间

​	2 HTTP是媒体独立的：意味只要客户端和服务器知道如何处理数据内容，任何类型的数据都可以通过HTTP发送，客户端以及服务器指定适合的MIME-type内容类型

​	3 HTTP是无状态：无状态指协议对于如何处理没有记忆能力。后续处理需要前面的信息，则它必须重传，这样可能导致每次链接传送的数据量增大。另一方面，在服务器不需要先前的信息时它的应答就较快。

#### 1.2 HTTP 消息结构

HTTP是基于客户端/服务端（C/S）的架构模型，通过一个可靠的链接来交换信息，是一个无状态的请求/响应协议。

客户端请求消息：

​	客户端发送一个HTTP请求到服务器消息格式：请求行（request line）、请求头部（header）、空行、请求数据，四个部分组成

![](https://raw.githubusercontent.com/ilnaygniy/picBed/master/httpclient.png)

服务器响应消息：

​	HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文

![](https://raw.githubusercontent.com/ilnaygniy/picBed/master/httpmessage.jpg)



### 2 TCP/IP 、UDP、HTTP协议

一次数据请求过程：

```
①：DNS解析域名得到IP地址
②：客户端与服务器建立连接(TCP三次握手)
③：客户端发起请求
④：服务器接收到请求根据端口号.路径等找到对应资源文件，响应源代码给客户端
⑤：客户端拿到请求到的数据(html页面的源代码)，开始解析页面以及请求资源
⑥：客户端渲染页面
⑦：web服务器断开连接(四次挥手)
```

![](https://raw.githubusercontent.com/ilnaygniy/picBed/master/fenceng.png)



![](https://raw.githubusercontent.com/ilnaygniy/picBed/master/fenceng2.png)



#### 2.1 TCP/UDP区别

##### 2.1.1 TCP

​	TCP协议全称传输控制协议，就是对传输过程中的数据又一定的控制。包头：

![](https://raw.githubusercontent.com/ilnaygniy/picBed/master/tcp.png)



源端口号/目的端口号：表示数据从哪个进程来，到哪个进程去。

32位序列号：。

4位首部长度：表示该tcp报头有多少个4字节（32bit）。

6位保留：。

6位标志位：

​	URG：标识紧急指针是否有效

​	ACK：标识确认序列号是否有效

​	PSH：用来提示接收端应用程序立刻将数据从tcp缓冲区读走

​	RST：要求重新连接。我们把含有RST标识的报文称为复位报文段

​	SYN：请求建立连接。我们把含有SYN标识的报文称为同步报文段

​	FIN：通知对端，本端即将关闭。我们把还有FIN标识的报文称为结束报文段

16位窗口大小：

16位紧急指针: 用来标识哪部分数据是紧急数据.



###### TCP最重要的三次握手和四次挥手



**三次握手：**

![](https://raw.githubusercontent.com/ilnaygniy/picBed/master/tcp2.png)

起初客户端和服务器都处于CLOSE状态。

此时客户端向服务器主动发出连接请求

**为什么不用两次握手：**

​	主要是为了防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送的第一个请求连接并且没有丢失，只是因为在网络中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时之前滞留的那一次请求连接，因为网络通畅了, 到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的费。

​	如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。



**四次挥手：**

![](https://raw.githubusercontent.com/ilnaygniy/picBed/master/tcp3.png)



1、客户端进程发出连接释放报文，并且停止发送数据。

2 、服务器是收到连接释放报文，发出确认报文。

3、客户端收到服务器确认请求后，进入FIN-WAIT-2（终止等待2）状态。

4、服务器将最后数据发送完毕后，就向客户端发送连接释放报文。

5、客户端收到连接释放报文后，必须发出确认。

6、服务器收到客户端确认后立即进入CLOSED状态。



**为什么客户端还要等待2*MSL的时间呢**

​	第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。

​	第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。



**为什么建立连接时三次握手，关闭连接却是四次挥手呢？**

​	建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。

​	而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。



**如果已经建立了连接，但是客户端突发故障怎么办？**

​	TCP设有一个保活计时器。



##### 2.1.2  UDP

​	用户数据报协议（UDP）是开放系统互联模型中传输层协议的一种，是一种保留消息边界的简单的面向数据报的协议。

​	UDP不提供差错纠正、队列管理、重复消除、流量控制和拥塞控制，但提供差错检测。UDP把数据报发出去，但并不保证他们能够到达目的地。UDP的无连接特性，它要比其它传输协议使用更少的开销。

![](https://raw.githubusercontent.com/ilnaygniy/picBed/master/udp.png)





##### 2.1.3 区别

1、TCP面向连接。UDP无连接。

2、TCP提供可靠的服务。UDP尽最大努力交付，即不保证可靠交付。

3、UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。

4、每一条TCP连接只能是点到点的；UDP支持一对一、一对多、多对一和多对多的交互通信。

5、TCP对系统资源要求较多，UDP对系统资源要求较少。



###### UDP优势

UDP以其简单、传输快的优势，在越来越多场景下取代了TCP,如实时游戏。

（1）网速的提升给UDP的稳定性提供可靠网络保障，丢包率很低，如果使用应用层重传，能够确保传输的可靠性。

（2）TCP为了实现网络通信的可靠性，使用了复杂的拥塞控制算法，建立了繁琐的握手过程，由于TCP内置的系统协议栈中，极难对其进行改进。





## 二  Okhttp

### 1 流程

流程图：**利用拦截器Interceptor讲整套框架纵向分层**，简化了设计逻辑，提升了框架扩张性。

![](https://raw.githubusercontent.com/ilnaygniy/picBed/master/okhttp1.png)





**具体的函数调用链**:

![](https://raw.githubusercontent.com/ilnaygniy/picBed/master/okhttp2.png)







### 2 Retrofit

涉及到的设计模式：外观模式，构建者模式，工厂模式，代理模式，适配器模式，策略模式，观察者模式。

原理：主要是通过动态代理将接口转换成代理对象。动态代理和静态代理的区别，动态代理直接在虚拟机层面构建字节码对象。